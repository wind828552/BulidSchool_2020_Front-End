<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style type="text/css">
        #demo input {
            width: 200px;
            border: none;
            border-bottom: 1px solid #ffffff;
            color: #ffffff;
            background: #20262e;
            outline: none;
        }

        #demo input[type="number"] {
            width: 60px;
        }

        #demo canvas {
            border: solid 1px #333333;
        }

        #demo button {
            cursor: pointer;
            color: #ffffff;
            background: #20262e;
            border: 1px solid #ffffff;
            outline: none;
            margin: 5px;
        }
    </style>

</head>

<body>

    <div id="demo">
        <canvas></canvas>
        <div>
            Image URL: <input type="text" value="https://i.imgur.com/77qgg2s.png"><br /> Maximum deep: <input
                type="number" value="31"><br /> Animation speed: <input type="number" value="200"><br />
            <button>Generate puzzle</button>
            <button>Solve puzzle</button>
            <button>Reshow animation</button>
        </div>
    </div>

    <script>
        (function () {
            /* HTML DOM */
            let demo = document.getElementById("demo");
            let canvas = demo.getElementsByTagName("canvas")[0];
            let context = canvas.getContext("2d");
            let urlNode = demo.getElementsByTagName("input")[0];
            let maxDeepNode = demo.getElementsByTagName("input")[1];
            let animationSpeedNode = demo.getElementsByTagName("input")[2];
            let shuffleNode = demo.getElementsByTagName("button")[0];
            let solveNode = demo.getElementsByTagName("button")[1];
            let animationNode = demo.getElementsByTagName("button")[2];

            /* 常數 */
            const N = 3; // 拼圖尺寸
            const ACTIONS = { // 動作常數
                UP: 0,
                RIGHT: 1,
                DOWN: 2,
                LEFT: 3
            };

            let imageURL = null; // 圖片位置
            let animationSpeed = 200; // 動畫速度
            let maxDeep = 10; // 最大搜索深度
            let S = null; // 初始狀態
            let image = new Image(); // 拼圖圖片
            let animation = []; // 動畫紀錄
            let interval = null; // 動畫控制變數
            let lock = true; // 控制鎖

            /* 策略 A */
            let h1 = function (s) {
                return s.map((e, i) => {
                    return e != 0 && e != i ? 1 : 0;
                }).reduce((p, c) => p + c);
            };

            /* 策略 B（不會用到，可參考）*/
            let h2 = function (s) {
                return s.map((e, i) => {
                    if (i != 0) {
                        let a = Math.abs(row(N, e) - row(N, i));
                        let b = Math.abs(column(N, e) - column(N, i));
                        return a + b;
                    }
                    return 0;
                }).reduce((p, c) => p + c);
            };

            /* 生成拼圖並洗牌 */
            shuffleNode.onclick = function () {
                clearInterval(interval);
                setting();
                animation = [];
                S = initialize(N, 100);
                image.src = imageURL;
                image.onload = function () {
                    refresh(S);
                    lock = false;
                };
            };

            /* 解拼圖 */
            solveNode.onclick = function () {
                clearInterval(interval);
                setting();
                queue.clear();
                let record = resolve(S, h1);
                animation = process(record);
                play();
            };

            /* 重放動畫 */
            animationNode.onclick = function () {
                play();
            };

            /* 播放動畫 */
            let play = function () {
                clearInterval(interval);
                setting();
                let tmp = Array.from(animation);
                interval = setInterval(function () {
                    let s = tmp.shift();
                    if (s) {
                        refresh(s);
                    } else {
                        clearInterval(interval);
                    }
                }, animationSpeed);
            };

            /* 調整設定值 */
            let setting = function () {
                imageURL = urlNode.value;
                animationSpeed = parseInt(animationSpeedNode.value);
                maxDeep = parseInt(maxDeepNode.value);
            };

            /* 繪製拼圖 */
            let refresh = function (s) {
                canvas.width = image.width;
                canvas.height = image.height;
                context.clearRect(0, 0, canvas.width, canvas.height);
                let k = N * N;
                let w = Math.floor(image.width / N);
                let h = Math.floor(image.height / N);
                for (let i = 0; i < k; i++) {
                    let index = s[i];
                    if (index != 0) {
                        let x = column(N, i) * w;
                        let y = row(N, i) * h;
                        let sx = column(N, index) * w;
                        let sy = row(N, index) * h;
                        context.drawImage(image, sx, sy, w, h, x, y, w, h);
                    }
                }
            };

            /* 檢查範圍 */
            Math.include = function (v, a, b) {
                return v >= a && v < b;
            };

            /* 交換元素 */
            Array.prototype.swap = function (i, j) {
                let t = this[i];
                this[i] = this[j];
                this[j] = t;
            };

            /* 陣列相等 */
            Array.prototype.equal = function (array) {
                if (array.length != this.length) {
                    return false;
                }
                for (let i = 0; i < this.length; i++) {
                    if (this[i] != array[i]) {
                        return false;
                    }
                }
                return true;
            };

            /* 註標轉換成列 */
            let row = function (n, index) {
                return Math.floor(index / n);
            };

            /* 註標轉換成行 */
            let column = function (n, index) {
                return index % n;
            };

            /* 操作動作 */
            let move = function (s, a) {
                let nextS = Array.from(s);
                let p = s.indexOf(0);
                switch (a) {
                    case ACTIONS.UP:
                        if (Math.include(row(N, p - N), 0, N)) {
                            nextS.swap(p, p - N);
                        }
                        break;
                    case ACTIONS.RIGHT:
                        if (row(N, p) == row(N, p + 1)) {
                            nextS.swap(p, p + 1);
                        }
                        break;
                    case ACTIONS.DOWN:
                        if (Math.include(row(N, p + N), 0, N)) {
                            nextS.swap(p, p + N);
                        }
                        break;
                    case ACTIONS.LEFT:
                        if (row(N, p) == row(N, p - 1)) {
                            nextS.swap(p, p - 1);
                        }
                        break;
                }
                return nextS;
            };

            /* 生成初始化盤面 */
            let initialize = function (n, step) {
                n = n * n;
                let s = Array.from({
                    length: n
                }, (_, i) => i);
                let keys = Object.keys(ACTIONS);
                for (let i = 0; i < step; i++) {
                    let k = keys[Math.floor(Math.random() * keys.length)];
                    let a = ACTIONS[k];
                    s = move(s, a);
                }
                return s;
            };

            /* 確認完成目標 */
            let goal = function (s) {
                return Array.from({
                    length: s.length
                }, (_, i) => i).equal(s);
            };

            /* 檢查存在盤面 */
            let have = function (array, s) {
                for (let v of array) {
                    if (v.equal(s)) {
                        return true;
                    }
                }
                return false;
            };

            /* 優先佇列 */
            let queue = {
                heap: [{
                    f: -1
                }],
                clear: function () {
                    this.heap = [{
                        f: -1
                    }];
                },
                empty: function () {
                    return !(this.heap.length > 1);
                },
                restore: function (node, leaf) {
                    while ((node * 2) <= leaf) {
                        let left = 2 * node;
                        let right = 2 * node + 1;
                        if (right > leaf) {
                            right = left;
                        }
                        let target;
                        if (this.heap[left].f < this.heap[right].f) {
                            target = left;
                        } else {
                            target = right;
                        }
                        if (this.heap[node].f < this.heap[target].f) {
                            break;
                        }
                        this.heap.swap(node, target);
                        node = target;
                    }
                },
                insert: function (node) {
                    this.heap.push(node);
                    let i;
                    for (i = this.heap.length - 1; this.heap[Math.floor(i / 2)].f > node.f; i = Math.floor(i / 2)) {
                        this.heap[i] = this.heap[Math.floor(i / 2)];
                    }
                    this.heap[i] = node;
                },
                get: function () {
                    let node = this.heap[1];
                    this.heap[1] = this.heap[this.heap.length - 1];
                    this.heap.pop();
                    this.restore(1, this.heap.length - 1);
                    return node;
                },
                node: function (previous, state, action, g, h) {
                    return {
                        previous: previous,
                        state: state,
                        action: action,
                        g: g,
                        f: g + h
                    };
                }
            };

            /* 求解盤面 */
            let resolve = function (state, h) {
                let create = queue.node;
                let record = [];
                let next = [];
                let actions = Object.keys(ACTIONS);
                queue.insert(create(null, state, null, 0, h(state)));
                while (!queue.empty()) {
                    let node = queue.get();
                    let state = node.state;
                    record.push(node);
                    if (goal(state)) {
                        return record;
                    }
                    let recordStates = record.map((node) => node.state);
                    for (let i of actions) {
                        let action = ACTIONS[i];
                        let nextStates = move(state, action);
                        if (!have(recordStates, nextStates)) {
                            let g = node.g + 1;
                            if (g >= maxDeep) {
                                break;
                            }
                            queue.insert(create(node, nextStates, action, g, h(nextStates)));
                        }
                    }
                }
                return record;
            };

            /* 從狀態紀錄生成動畫 */
            let process = function (record) {
                let animation = [];
                let target = record[record.length - 1];
                while (target) {
                    animation.push(target.state);
                    target = target.previous;
                }
                return animation.reverse();
            };

            setting();
            image.src = imageURL;
            image.onload = function () {
                S = initialize(N, 100);
                refresh(S);
                lock = false;
            };
        })();
    </script>
</body>

</html>